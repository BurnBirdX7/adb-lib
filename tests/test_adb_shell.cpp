#include <AdbDevice.hpp>
#include <UsbTransport.hpp>

#include <iostream>

int main(int argc, char** argv) {
    if (argc != 3) {
        std::cerr << "You have to provide paths to private and public keys generated by adb keygen" << std::endl;
        return 1;
    }

    const char* privateKey = argv[1];
    const char* publicKey = argv[2];


    auto usbContext = ObjLibusbContext::make();
    usbContext->spawnEventHandlingThread().detach();

    std::cout << "Searching for ADB Device..." << std::endl;
    std::unique_ptr<UsbTransport> transport;
    {   // Find transport
        auto vector = usbContext->getDeviceVector();
        for (const auto& device : vector) {
            auto interface = UsbTransport::findAdbInterface(device);
            if (!interface)
                continue;

            std::cout << "Device found. Read address: " << (int)interface->readEndpointAddress << ", "
            << "write address: " << (int)interface->writeEndpointAddress << std::endl;

            transport = UsbTransport::make(device);
            if (transport)
                break;
        }
    }   // ! Find transport

    if (!transport) {
        std::cout << "Couldn't create any transports" << std::endl;
        return 0;
    }
    std::cout << "Transport created." << std::endl
    << "Connecting to the device..." << std::endl;

    auto device = AdbDevice::make(std::move(transport));

    // ADD KEYS TO BE ABLE TO CONNECT TO DEVICE THAT REQUIRES AUTHORIZATION
    device->addPrivateKeyPath(privateKey);
    device->setPublicKeyPath(publicKey);

    // CONNECT TO THE DEVICE
    device->connect();
    if (!device->isConnected()) {
        std::cout << "Couldn't establish connection with the device." << std::endl;
        return 0;
    }
    std::cout << "Device connected." << std::endl;
    std::cout << "Info:"
    << " Product: " << device->getProduct() << std::endl
    << "\t  Model: " << device->getModel() << std::endl
    << "\t  Device: " << device->getDevice() << std::endl
    << "\t  Serial: " << device->getSerial() << std::endl
    << "\t  System Type: " << device->getSystemType() << std::endl
    << std::endl;

    bool shell2 = false;

    std::cout << "Features: " << std::endl;
    if (!device->getFeatures().empty()) {
        for (const auto& feature : device->getFeatures()) {
            std::cout << "\t* " << feature << std::endl;
            if (feature == Feature::shell2)
                shell2 = true;
        }
    }
    else
        std::cout << " <none> " << std::endl;
    std::cout << std::endl;

    if (!shell2) {
        std::cerr << "This device lacks required feature (shell2)" << std::endl;
        return 1;
    }

    std::string dest = "shell:";
    std::cout << "Opening stream to " << dest << "..." << std::endl;

    // OPEN STREAM TO A CHOSEN DESTINATION
    auto streams = device->open(dest);
    if (!streams) {
        std::cerr << "Couldn't open the streams." << std::endl;
        return 1;
    }

    std::cout << "The streams opened." << std::endl;
    auto& in = streams->istream;
    auto& out = streams->ostream;

    std::string label;
    in >> label;

    std::string userInput{};
    while (in.isOpen() && out.isOpen()) {
        std::string result;

        std::cout << std::endl << label;
        std::getline(std::cin, userInput);
        if (userInput == "q")
            break;

        out << userInput + '\n';

        do { // exhaust input stream
            in >> result;
            std::cout << result;
        } while (!in.isEmpty());
    }

    return 0;
}
